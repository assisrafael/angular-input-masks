'use strict';

module.exports = function maskFactory(maskDefinition) {

	function MaskDirective($timeout) {
		var caret = {
			set : function caretSet(element, pos){
				if(element.setSelectionRange) {
					element.focus();
					element.setSelectionRange(pos,pos);
				} else if (element.createTextRange) {
					var range = element.createTextRange();
					range.collapse(true);
					range.moveEnd('character', pos);
					range.moveStart('character', pos);
					range.select();
				}
			},
			get : function caretGet(element) {
				var iCaretPos = 0;
				if (document.selection) {
					element.focus();
					var oSel = document.selection.createRange();
					oSel.moveStart('character', -element.value.length);
					iCaretPos = oSel.text.length;
				} else if (element.selectionStart || element.selectionStart === '0') {
					iCaretPos = element.selectionStart;
				}
				return iCaretPos;
			}
		};

		return {
			restrict: 'A',
			require: 'ngModel',
			link: function(scope, element, attrs, ctrl) {
				ctrl.$formatters.push(function formatter(value) {
					if (ctrl.$isEmpty(value)) {
						return value;
					}

					var cleanValue = maskDefinition.clearValue(value);
					return maskDefinition.format(cleanValue);
				});

				ctrl.$parsers.push(function parser(value) {

					$timeout(function(){

						if (ctrl.$isEmpty(value)) {
							return value;
						}

						var cleanValue = maskDefinition.clearValue(value);
						var formattedValue = maskDefinition.format(cleanValue);

						var currentCaretPosition = caret.get(element[0]),
							lengthBefore = ctrl.$viewValue.length,
							lengthAfter = 0;

						if (ctrl.$viewValue !== formattedValue) {
							ctrl.$setViewValue(formattedValue);
							ctrl.$render();

							lengthAfter = ctrl.$viewValue.length;
						}

						var caretFormatDiffer = (lengthAfter - lengthBefore) < 0 ? 0 : lengthAfter - lengthBefore;

						caret.set(element[0], currentCaretPosition + caretFormatDiffer);

						if (angular.isUndefined(maskDefinition.getModelValue)) {
							return cleanValue;
						}

						var actualModelType = typeof ctrl.$modelValue;
						return maskDefinition.getModelValue(formattedValue, actualModelType);
					},0);
				});

				angular.forEach(maskDefinition.validations, function(validatorFn, validationErrorKey) {
					ctrl.$validators[validationErrorKey] = function validator(modelValue, viewValue) {
						return ctrl.$isEmpty(modelValue) || validatorFn(modelValue, viewValue);
					};
				});
			}
		};
	};

	MaskDirective.$injector = ['$timeout'];

	return MaskDirective
};